# CVE-2021-22555 Analysis Report

### Analysis report on Local Privilege Escalation   

### Caused by Out-of-bounds in the Linux Netfilter module



<table>
  <tr>
    <td><b>First Author</b></td>
    <td>Andy Nguyen</td>
  </tr>
  <tr>
    <td><b>Author</b></td>
    <td>iCAROS7 (Homin Rhee)</td>
  </tr>
  <tr>
    <td><b>Data Created</b></td>
    <td>2022.07.18 Mon</td>
  </tr>
  <tr>
    <td><b>Data Version</b></td>
    <td>1.0.2</td>
  </tr>
</table>


# Index

1. Introduce
2. Analysis of crash occurrence function
   1. Basic knowledge
      1. `__alignof__` value per architecture

   2. Code audit
   3. Vulnerability analysis
3. Crash inducement
   1. Host PC specification
   2. Vulnerability analysis

4. Proof of concept
   2. For KASLR leak
   3. For local privilege escalation
5. Patch for the vulnerability
6. Conclusion
7. Reference

# 1. Introduce

 CVE-2021-22555는 user namespace 내에서 contaning 되어있는 application이 heap Out-of-bounds를 통해 privilege escalation이 가능한 취약점 이다.

 Linux kernel의 network 관련 handler type의 framework인 `netfilter` 내에서 trigger 된다. 2006년경 modified 된 `x_tables` module 내 `xt_compat_match()`에서 type-safe 의 목적으로 split 된 function으로부터 시작 된다.
`xt_compat_match_from_user()` 및 `xt_compat_target_from_user()` 내 type integer으로 선언 된 incompleteness한 variable `pad` 에 의하여 induce 된다.

 Linux kernel version 2.6.19 ~ 4.4.265, ~ 4.9.265, ~ 4.14.229, ~ 4.19.186, ~ 5.4.111, ~ 5.10.29, ~ 5.12 까지의 광범위한 범위를 지닌다.

 2021년 4월 6일 `Andy Nguyen`에 의해 최초 보고 되었으며, 동년 동월 13일 Linux main upstream branch에 patch가 `Florian Westphal`로부터 merge되며 각 vendor에게 release 되었다. 이후 동년 7월 7일 public release 되며 CVSS 3.0 기준 `7.8 High`로 scoring 되었다.

# 2. Analysis of crash occurrence function
## 2-1. Basic knowledge
### 2-1-1. `__alignof__` value per architecture

 `__alignof__`의 return value는 argument로 주어진 data의 alignment을 위해 필요한 byte이다. 이를 이용하여 하기와 같아 compile을 수행한 architecture의 register의 bit를 확인하는 용도로도 활용이 가능하다.

```c
/* this is a dummy structure to find out the alignment requirement for a struct
 * containing all the fundamental data types that are used in ipt_entry,
 * ip6t_entry and arpt_entry.  This sucks, and it is a hack.  It will be my
 * personal pleasure to remove it -HW
 */

struct _xt_align {
	__u8 u8;
	__u16 u16;
	__u32 u32;
	__u64 u64;
};

#define SIZE __alignof__(struct _xt_align)
```

 `u8`, `u16`, `u32`, `u64`이  declaration 된 struct의 `__alignof__`를 수행 시 가장 큰 type data를 기준으로 return 한다.

## 2-2. Code audit

```c
# /net/netfilter/x_tables.c

void xt_compat_match_from_user(struct xt_entry_match *m, void **dstptr, int *size)
{
	struct xt_match *match = m->u.kernel.match;
	struct compat_xt_entry_match *cm = (struct compat_xt_entry_match *)m;
	int pad, off = xt_compat_match_offset(match);
	u_int16_t msize = cm->u.user.match_size;

	m = *dstptr;
	memcpy(m, cm, sizeof(*cm));
	if (match->compat_from_user)
		match->compat_from_user(m->data, cm->data);
	else
		memcpy(m->data, cm->data, msize - sizeof(*cm));
	pad = XT_ALIGN(match->matchsize) - match->matchsize;
	if (pad > 0)
		memset(m->data + match->matchsize, 0, pad);

	msize += off;
	m->u.user.match_size = msize;

	*size += off;
	*dstptr += msize;
}
```

 우선 **Line. 5~8**에서는 argument로 넘어온 `xt_entry_match` struct를 User Kernel Match data의 address를 `m`에 가져온다. 다음  `compat_xt_entry_match` type struct pointer `cm`에 arguments의 `m`을 `compat_xt_entry_match`으로 type conversion 하여 대입한다.

 이후 type integer의 `pad`를 선언하며 `off`를 `xt_compat_match_offset()` 의 return data로 `compatsize`의 value에 따라 (`matchsize` + `__alignof__` - 1) -`compatsize`를 통해 allocating 한다. 여기서 `__alignof__`로 define 된 value는 compile를 진행한 architecture에 따라 결정된다. 따라서  `matchsize` + `n` - `compatsize`로 둘의 value difference가 대입된다. 다음 type unsigned 16bit integer `msize`에 argument의 user.match_size를 가져온다.

 **Line. 10, 11**에서는 `m` pointer 의 address를 argument의 `dstptr`로 change 한다. 이후 `memcpy()` 을 통해 `dstptr`의 data를 다시 `cm`의 address로 `cm`의 size 만큼 copy 한다.

 **Line 12~15**의  if 문에서 kernel space 상에서 별도의 align이 필요할 경우 Kernel config 내 `CONFIG_COMPAT` boolean value에 따라 존재가 결정되는 `compat_from_user()`가 조건이 된다. `compat_from_user()`이 존재한다면 arguments로 `m`과 `cm`의 data로 넘겨 `cm`의 data를 최종적으로 `m`의 data에 넘긴다. 만일 존재하지 않는다면 `memcpy()`로 `cm` struct의 data를 `m` struct의 `data`로 copy 한다.

 **Line. 16~18**에서 variable  `pad`에 위에서 1회 연산 되었던 `XT_ALIGN(matchsize)`와 `matchsize`를 subtraction한다. 이는 architecture에 따라 다른 값이 나온다. 이때 if 문의 condition에 따라 **Line. 16**의 `pad` 값이 0보다 큰 경우에는 `memset()`을 통해 struct `m`의 `data` address 와 struct  `match`의 `match` address의 합에 `0`을 `pad` value 만큼 memory를 initalization 한다.

 **Line. 20, 21**에서 `msize`의 값을 **Line. 7**에서 계산된 `off` value 만큼 increase 시킨 뒤, user.match_size를 `msize`에 대입한다. 이후 **Line 23, 24**에서 argument의 pointer `size`의 값 역시 `off` value 만큼 increase 시킨 다음 pointer `dstptr` 역시 `msize` 만큼 increase 한다.

```C
void xt_compat_target_from_user(struct xt_entry_target *t, void **dstptr,
				unsigned int *size)
{
	const struct xt_target *target = t->u.kernel.target;
	struct compat_xt_entry_target *ct = (struct compat_xt_entry_target *)t;
	int pad, off = xt_compat_target_offset(target);
	u_int16_t tsize = ct->u.user.target_size;
	char name[sizeof(t->u.user.name)];												// [1]

	t = *dstptr;
	memcpy(t, ct, sizeof(*ct));
	if (target->compat_from_user)
		target->compat_from_user(t->data, ct->data);
	else
		memcpy(t->data, ct->data, tsize - sizeof(*ct));
	pad = XT_ALIGN(target->targetsize) - target->targetsize;
	if (pad > 0)
		memset(t->data + target->targetsize, 0, pad);

	tsize += off;
	t->u.user.target_size = tsize;

	strlcpy(name, target->name, sizeof(name));								// [2]
	module_put(target->me);																		// [3]
	strncpy(t->u.user.name, name, sizeof(t->u.user.name));		// [4]
	*size += off;
	*dstptr += tsize;
}
```
 `xt_compat_target_from_user()` 역시 `xt_compat_match_from_user()`와 비슷한 mechanism으로 동작하지만 차이점은 다음과 같다.

 **[1]**에서 type char으로 `user.name`의 size 만큼 array를 구성한다. 이후 `memset` function으로 memory initalization 까지 동일하게 진행된다.

 **[2]** `strlcpy` function으로 `\0`을 포함하여 `target` struct의 `name`을 **[1]**에서 declaration 된 `name`에 copy 한다. 이후 **[3]**에서 User가 request한 netfilter table의 re-allocating을 위해 target indexing을 목적으로 call 되는 netfilter의 `conntrack_bridge` module의 reference counter가 1회 incrase 되었던 것을 다시 decrease 시킨다.

 **[4]**에서 다시금 `strncpy` function을 통해 user.name에 `name`의 address에 u.user.name의 size만큼 copy 한다.

## 2-3. Vulnerability analysis

 실질적으로 vulnerability 한 code는 하기와 같다.

```c
# xt_compat_match_from_user
	int pad, off = xt_compat_match_offset(match);

	pad = XT_ALIGN(match->matchsize) - match->matchsize;
	if (pad > 0)
		memset(m->data + match->matchsize, 0, pad);

# xt_compat_target_from_user
	int pad, off = xt_compat_target_offset(target);

	pad = XT_ALIGN(target->targetsize) - target->targetsize;
	if (pad > 0)
		memset(t->data + target->targetsize, 0, pad);
```

 **Line. 2, 9** 및 **Line. 4, 11**은 type integer으로 declaration 된 variable `pad`에 compile를 진행한 architecture 별 value difference를 연산한다. 

```c
/* /linux/net/netfilter/x_tables.h */

#define XT_ALIGN(s) __ALIGN_KERNEL((s), __alignof__(struct _xt_align))

/* /linux/include/uapi/linux/const.h */
#define __ALIGN_KERNEL(x, a)		__ALIGN_KERNEL_MASK(x, (typeof(x))(a) - 1)
#define __ALIGN_KERNEL_MASK(x, mask)	(((x) + (mask)) & ~(mask))
```

 이후 `memset()` 및 null padding을 이용한 architecture 간 `m` struct convertion 과정에서 `matchsize` 및 `targetsize`에 대한 value verification이 없다. 이로인하여  `memset()`의 3rd argument로 `size_t num`에 abnormal한 `pad` value가 들어갈 경우 oob가 triger 된다.

# 3. Crash-inducement

## 3-1. Host PC specification

- OS Version: Ubuntu 20.04.04 LTS (Focal Fossa)
- Kernel Version: Linux 5.13.0-52-generic amd64
- CPU: Intel(R) Core(TM) i7-2620M CPU @ 2.70GHz
- RAM: PC3L-12800 1600MHz 12GB
  - Swap File Size: 16GB

# 4. Proof of concept

# 5. Patch for the vulnerability

```c
/* /linux/net/netfilter/x_tables.c */

	void xt_compat_match_from_user(struct xt_entry_match *m, void **dstptr,
				       unsigned int *size)
	{
		const struct xt_match *match = m->u.kernel.match;
		struct compat_xt_entry_match *cm = (struct compat_xt_entry_match *)m;
-		int pad, off = xt_compat_match_offset(match);
+		int off = xt_compat_match_offset(match);						// [1]
		u_int16_t msize = cm->u.user.match_size;
		char name[sizeof(m->u.user.name)];

		m = *dstptr;
		memcpy(m, cm, sizeof(*cm));
		if (match->compat_from_user)
			match->compat_from_user(m->data, cm->data);
		else
			memcpy(m->data, cm->data, msize - sizeof(*cm));
-		pad = XT_ALIGN(match->matchsize) - match->matchsize;
-		if (pad > 0)
-			memset(m->data + match->matchsize, 0, pad);				// [2]

		msize += off;
		m->u.user.match_size = msize;
```

```C
/* /linux/net/netfilter/x_tables.c */

	void xt_compat_target_from_user(struct xt_entry_target *t, void **dstptr,
					unsigned int *size)
	{
		const struct xt_target *target = t->u.kernel.target;
		struct compat_xt_entry_target *ct = (struct compat_xt_entry_target *)t;
-		int pad, off = xt_compat_target_offset(target);
+		int off = xt_compat_target_offset(target);					// [1]
		u_int16_t tsize = ct->u.user.target_size;
		char name[sizeof(t->u.user.name)];

		t = *dstptr;
		memcpy(t, ct, sizeof(*ct));
		if (target->compat_from_user)
			target->compat_from_user(t->data, ct->data);
		else
			memcpy(t->data, ct->data, tsize - sizeof(*ct));
-		pad = XT_ALIGN(target->targetsize) - target->targetsize;
-		if (pad > 0)
-			memset(t->data + target->targetsize, 0, pad);			// [2]

		tsize += off;
		t->u.user.target_size = tsize;
```

우선 **[1]** 및 **[2]**와 같이  initialization을 목적으로 하는 memory access 자체를 행하지 않게 하여 직접적으로 unintend 한 memory access를 막을 수 있다.

```c
/* /linux/net/ipv4/netfilter/arp_tables.c */

	static int translate_compat_table(struct net *net,
					  struct xt_table_info **pinfo,
					  void **pentry0,
					  const struct compat_arpt_replace *compatr)
	{
	  ret = -ENOMEM;
		newinfo = xt_alloc_table_info(size);
		if (!newinfo)
			goto out_unlock;

+		memset(newinfo->entries, 0, size);				// [3]

		newinfo->number = compatr->num_entries;
```

```c
/* /linux/net/ipv4/netfilter/ip_tables.c */
	
	static int get_info(struct net *net, void __user *user, const int *len)
	{
+		memset(&info, 0, sizeof(info));						// [3]
		info.valid_hooks = t->valid_hooks;
		memcpy(info.hook_entry, private->hook_entry,
		       sizeof(info.hook_entry));
```

```c
/* /linux/net/ipv6/netfilter/ip6_tables.c */

	static int get_info(struct net *net, void __user *user, const int *len)
	{
+		memset(&info, 0, sizeof(info));						// [3]
		info.valid_hooks = t->valid_hooks;
		memcpy(info.hook_entry, private->hook_entry,
		       sizeof(info.hook_entry));
```

 이후 실질적으로 `do_ipt_get_ctl()`과 같은 `xt_compat_*_from_user()` 을 call 하는 parent에서 이용되는 `get_info`에서 최종적으로 결정된 target의 size를 `sizeof()`을 통해 `memset()` 하여 주는 것으로 patch가 가능하다.

# 6. Conclusion

 위 vulnerability code의 경우 local 상에서 complexity가 high 하지 않게 low-preivilieges status에서 별도의 user interaction 없이 system confidentiality / integritiy / availability에 상당한 영향력을 끼치므로 높게 scoring 되었다. USD 기준 추정 $5,000 ~ $25,000의 bug bounty가 offer 된 것으로 추정 된다.

 본 report는 version `1.0.2`까지 author의 skill 부족으로 인해 Proof of Concept을 포함하지 못하였다. 이후 해당 issue가 해결된다면 지울 part 이다.

 하기와 같은 component가 앞으로 learning이 필요하다 teach 받았다.

- Checkout each mitgation mechanism
- Learning about mitgation bypass without `pwntools`
- Basic level binary exploit via C PoC
- Auditing and write write-up without online searching at auditing stage
- About heap grooming

# 7. Reference

- https://www.cvedetails.com/cve/CVE-2021-22555/
- https://ubuntu.com/security/CVE-2021-22555
- https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-22555
- https://nvd.nist.gov/vuln/detail/CVE-2021-22555
- https://access.redhat.com/security/cve/CVE-2021-22555
- https://vulners.com/cve/CVE-2021-22555
- https://github.com/torvalds/linux/commit/b29c457a6511435960115c0f548c4360d5f4801d
- https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/net/netfilter/x_tables.c?id=b29c457a6511435960115c0f548c4360d5f4801d
- https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/net/netfilter/x_tables.c?id=9fa492cdc160cd27ce1046cb36f47d3b2b1efa21
- https://lore.kernel.org



- https://www.netfilter.org
- https://en.wikipedia.org/wiki/Iptables
- https://www.digitalocean.com/community/tutorials/a-deep-dive-into-iptables-and-netfilter-architecture
- https://programmer.group/netfilter-framework-of-linux-kernel.html



- https://elixir.bootlin.com
- https://jybaek.tistory.com/160
- https://gcc.gnu.org/onlinedocs/gcc-6.2.0/gcc/Alignment.html
- https://www.ibm.com/docs/en/i/7.4?topic=expressions-alignof-operator
- https://blog.katastros.com/a?ID=01550-a475cf58-24f4-403a-9f6e-8a800ba9ae14