# CVE-2013-6282 Analysis Report

### Analysis report on Local Privilege Escalation   

### Caused by Improper Input Validation in the `get_user` and `put_user` API 



<table>
  <tr>
    <td><b>First Author</b></td>
    <td>Catalin Marinas</td>
  </tr>
  <tr>
    <td><b>Author</b></td>
    <td>iCAROS7 (Homin Rhee)</td>
  </tr>
  <tr>
    <td><b>Data Created</b></td>
    <td>2022.09.20 Tue</td>
  </tr>
  <tr>
    <td><b>Data Version</b></td>
    <td>1.0.0</td>
  </tr>
</table>


# Index

1. Introduce
2. Analysis of crash occurrence function
   1. Basic knowledge
      1. Difference of `copy_{to, from}_user()`between `{get, put}_user()`
      2. ARM Domain
   2. Code audit
   3. Vulnerability analysis
3. Crash inducement
   1. Vulnerability analysis
4. Proof of concept
5. Patch for the vulnerability
6. Conclusion
7. Reference



# 1. Introduce

 CVE-2013-6282는 `arm` 아키텍처의 도메인 전환 기능 사용시 적절치 못한 매개변수 검증으로 인해 권한 상승이 가능한 취약점이다.

 이는 2005년 `Linux-2.6.12-rc2` 에서 `arm` 아키텍처용으로 추가된 userland 와 kernel space 간 데이터 전송 메서드인 `get_user()` 및 `put_user()` 내에서 유발 된다. 데이터 전송시 userland와 kernel space의 포인터에 데이터를 읽고 쓰는 과정에서 대상 메모리 주소에 대한 입력 검증이 이루어지지 않아 공격자가 원하는 메모리 주소에 원하는 데이터를 넣을 수 있게 된다.

 Linux kernel version 3.5.4 이하의 모든 ARMv6k 및 ARMv7 구성을 사용하는 모든 기기에 해당된다. 이는 실질적으로 2010-13년경 출시된 대부분의 Android 기기에 영향을 미치므로 상당한 위험성을 내제하고 있다. 또한 이미 이를 통해 상당수의 Android 기기가 Local Privilege Escalation (이하 LPE)를 통해 실제로 root 권한을 사용자가 의도적으로 얻어 시스템에 접근하는 rooting 사례가 보고 되었다.

 2012년 9월 9일 `Catalin Marinas`에 의해 최초 보고 되었으며, 동년 동월 10일 Linux main stream에 즉각 커밋 되었다. 이후 다음 해 11월 19일 공개 되며 CVSS 2.0 기준 `7.2`로 점수를 받았다.

# 2. Analysis of crash occurrence function
## 2-1. Basic knowledge
### i. Difference of `copy_{to, from}_user()`between `{get, put}_user()`
 `copy_{to, from}_user()` 역시 `{get, put}_user()`와 동일하게 userland와 kernel space 간 데이터를 주고 받는데 사용이 가능하다. 차이는 전자의 경우 struct를 포함하여 대다수의 자료형과 구조에 대응이 가능하다. 허나 후자는 char, int 그리고 long 등 간단한 자료형에만 사용이 가능하다.

 ARM의 경우 `1`, `2`, `4` byte까지 지원을 하나 2012년 11월 경 추가된 `[PATCH] ARM: add get_user() support for 8 byte types` commit 이후 Linux kernel 3.7 부터 64 bit 자료형인 `8` byte까지 지원한다.

### ii. TLB (Translation Lookaside Buffer)

 TLB는 Userland의 요청자와 통신하며 가상의 메모리 주소를 물리 주소로 변환하는 용도와 이와 관련된 각각의 접근 권한 제어를 캐싱하는 역할을 한다. 이 중 상위의 Memory Management Unit (이하 MMU)의 접근 제어 로직에게 주어진 가상의 메모리 주소가 접근이 가능 정책을 사용하는지 반환 받는다. 접근이 가능하다면 MMU로부터 물리 주소를 반환받아 요청자에게 다시 반환한다. 접근이 불허하다면 CPU 단에서 요청자에게 `abort` 신호를 반환한다. 이는 각각의 주소 별로 캐싱되어 다음번 요청이 들어올 때 빠른 응답이 가능하게 한다.

 각 주소에 관한 TLB가 없다면 위와 같은 동작을 통해 캐싱을 하며 이는 table 형식으로 저장된다. 이를 내부적으로는 `entry`라 칭한다. 이때 entry는 새롭게 갱신되어 캐싱될 경우 기존 정보가 지워 질 수 있다.

### iii. MMU (Memory Management Unit)

 CPU 내에서 가상의 주소를 물리 메모리로 변환하며, 메모리 접근 권한을 제어하는 유닛이다. 이는 무조건 1개 이상의 TLB, 접근 제어 로직과 요청받은 주소에 대한 TLB가 없을때 병렬 수행되는 `Translation Table Walking` 로직으로 구성 되어있다.

 전자 2개의 경우 위 TLB 단에서 설명이 되었으므로 `Translation Table Walking`에 관한 것만 추후 기술 한다. MMU의 메모리 관리 방식으로는 다음과 같은 두가지가 있다.

- Section
  - 1MB의 Block 단위로 관리
- Page
  - Small Page: 4kB Block 메모리로 관리
    - 1kB의 Sub Page
  - Large Page: 64kB Block 메모리로 관리
    - 16kB의 Sub Page

 Section 및 large page의 경우 TLB에 특정 하나의 `entry`만이 큰 영역을 매핑 가능하다.

### iv. ARM Domain

 Domain은 ARM architecture에만 있는 메모리 구역 관리 시스템 이다. 현 ARM의 경우 `Domain Access Control Register`를 통해 총 16개의 domain 구성을 지원한다. 또한 이 domain 내에는 무조건 상호 연결된 도메인이 존재한다.

 이는 다음 행동 중 하나의 정책을 각 메모리 구역에 할당이 가능하다.

1. 무조건 접근 허용
2. 무조건 접근 불허
3. 부분적 접근 허용

 케이스 1, 2의 경우 Domain 내 별도 권한 속성이 있더라도 무시되며 위 정책이 최우선 적용된다. 

## 2-2. Code audit

> 하기 모든 Code는 Linux Kernel 3.5.4를 기준으로 한다.

```c
// File: /arch/arm/include/asm/uaccess.h

extern int __get_user_1(void *);
extern int __get_user_2(void *);
extern int __get_user_4(void *);

#define __get_user_x(__r2,__p,__e,__s,__i...)		\
	   __asm__ __volatile__ (			\
		__asmeq("%0", "r0") __asmeq("%1", "r2")	\
		"bl	__get_user_" #__s		\				// asms, ASM 코드
		: "=&r" (__e), "=r" (__r2)		\	// output, 결과 출력 변수
		: "0" (__p)				\							// input, asms에 넘겨줄 입력 변수
		: __i, "cc")										// clobber, 상기에 명시되진 않았지만 asms로 인해 값이 변하는 변수
```
 `__getuser_x()`는 단일 값 전송 메서드이다. Pointer가 정상적으로 할당 되었다면 크기는 자동으로 계산된다.

 `__volatile__()`를 통해 인라인 asm 시 최적화 등의 의도치 않은 이동을 방지한다. `__asmeq()`를 통해 두번째 인자  레지스터에 asm 변수에 해당하는 첫번째 인자 asm 변수 값이 정상적으로 mapping 되었나 확인한다. 이때 정상적으로 할당 되지 않았다면 컴파일 작업이 중단된다.

 `bl` 명령을 통해 현재의 R15 `PC` 레지스터의 값을 R14 `LR` 레지스터에 복사하여 분기 이후 되돌아올 주소를 현 R15 `PC` 레지스터의 값으로 지정한 뒤 `__get_user_n()`를 수행한다. 이때 `n`의 경우 4번째 인자로 받은 `__s` 값을 사용한다. 이때 `equal` 오퍼랜드와 `__p`로 받은 주소 값을 넘겨준다. 위 asms 연산 중 첫번째 값을 `__e` 주소 값에 이전 값을 버리고 쓰기 전용으로 쓴다. 이후 `__r2` 주소 값에 전자와 동일하게 쓰기 전용으로 쓴다. 모든 asms가 끝나고 난다면 `__i` 주소 값과 `CC` Carry 레지스터의 값이 `0`으로 변함을 명시한다.

```c
#define __put_user_x(__r2,__p,__e,__s)		\
__asm__ __volatile__ (				\
     __asmeq("%0", "r0") __asmeq("%2", "r2")	\
     "bl	__put_user_" #__s		\			// asms, ASM 코드
     : "=&r" (__e)				\					// output, 결과 출력 변수
     : "0" (__p), "r" (__r2)			\	// input, asms에 넘겨줄 입력 변수
     : "ip", "lr", "cc")						// clobber, 상기에 명시되진 않았지만 asms로 인해 값이 변하는 변수
```
 `__get_user_x()`와 비슷한 메커니즘으로 동작하지만 차이점만 짚어보겠다. asms 수행시 `equal` 오퍼랜드와 `__p`로 받은 주소 값을 첫번째로, 쓰기 전용으로 이전 값을 버리고 `__r2` 주소 값을 넘겨준다. 이후 연산 중 `__e`의 이전 값을 버리고 새로운 값을 쓴다. 모든 asms가 끝나고 난다면 R12 `IP` Intra scratch 레지스터와 R14 `LR` Link Register의 복귀 주소가 바뀜을 명시한다.

```c
#define get_user(x,p)							\
	({								\
		register const typeof(*(p)) __user *__p asm("r0") = (p);\
		register unsigned long __r2 asm("r2");			\
		register int __e asm("r0");				\
		switch (sizeof(*(__p))) {				\
		case 1:							\
			__get_user_x(__r2, __p, __e, 1, "lr");		\
	       		break;						\
		case 2:							\
			__get_user_x(__r2, __p, __e, 2, "r3", "lr");	\
			break;						\
		case 4:							\
	       		__get_user_x(__r2, __p, __e, 4, "lr");		\
			break;						\
		default: __e = __get_user_bad(); break;			\
		}							\
		x = (typeof(*(p))) __r2;				\
		__e;							\
	})
```
 실질적으로 사용되는 `get_user()`이다. userland 상의 포인터로부터 단일 값 `x`를 가져온다. 전반적인 흐름은 사용될 변수들이 정의 되고 크기에 따라 switch 문을 통해 `get_user_n()`으로 분배된다.

 `register` 키워드로 R0 레지스터에 static 하게 저장이 되는 변수 `__p`를 하나 만들어준다. 형식은 매개변수로 받은 `p`와 같은 형식으로 한다. 동일하게 `R2` 레지스터에 저장되는 unsigned long 형식의 변수 `__r2`를 정의한다. R0 레지스터에 저장되는 `__e`도 하나 정의 한다.

 `sizeof()`를 사용하여 매개변수로 받은 `p`의 크기에 따라 switch-case 문을 실행한다. 이때 올바르지 않은 형식의 경우 `__get_user_bad()`를 호출하여 원치 않는 메모리 읽기 쓰기를 차단한다.

 이후 새롭게 userland로부터 가져온 R2 레지스터의 값을 `typeof()`로 자료형을 맞추어 x에  대입한다.

```c
#define put_user(x,p)	\
	({	\
		register const typeof(*(p)) __r2 asm("r2") = (x);	\
		register const typeof(*(p)) __user *__p asm("r0") = (p);\
		register int __e asm("r0");				\
		switch (sizeof(*(__p))) {				\
		case 1:							\
			__put_user_x(__r2, __p, __e, 1);		\
			break;						\
		case 2:							\
			__put_user_x(__r2, __p, __e, 2);		\
			break;						\
		case 4:							\
			__put_user_x(__r2, __p, __e, 4);		\
			break;						\
		case 8:							\
			__put_user_x(__r2, __p, __e, 8);		\
			break;						\
		default: __e = __put_user_bad(); break;			\
		}							\
		__e;							\
	})
```

 `put_user()` 메서드도 `get_user()` 메서드와 동일한 메커니즘으로 동작한다. 차이 점만 짚어보자면 R2 레지스터에 static 값으로 userland로 넘겨줄 포인터 `p`의 자료형에 따라 `__r2` 가 정의 되고 해당 값에 매개변수로 들어온 `x`의 주소를 대입한다. 이후 동일하게 R0 레지스터에 static 한 `__p` 포인터를 정의하여  `p`의 주소를 대입한다.

```c
// File: /arch/arm/lib/getuser.S

#include <linux/linkage.h>
#include <asm/errno.h>
#include <asm/domain.h>

ENTRY(__get_user_1)
1: TUSER(ldrb)	r2, [r0]
	mov	r0, #0
	mov	pc, lr
ENDPROC(__get_user_1)

ENTRY(__get_user_2)
#ifdef CONFIG_THUMB2_KERNEL
2: TUSER(ldrb)	r2, [r0]
3: TUSER(ldrb)	r3, [r0, #1]
#else
2: TUSER(ldrb)	r2, [r0], #1
3: TUSER(ldrb)	r3, [r0]
#endif
#ifndef __ARMEB__
	orr	r2, r2, r3, lsl #8
#else
	orr	r2, r3, r2, lsl #8
#endif
	mov	r0, #0
	mov	pc, lr
ENDPROC(__get_user_2)

ENTRY(__get_user_4)
4: TUSER(ldr)	r2, [r0]
	mov	r0, #0
	mov	pc, lr
ENDPROC(__get_user_4)
  
// File: /arch/arm/lib/putuser.S

#include <linux/linkage.h>
#include <asm/errno.h>
#include <asm/domain.h>

ENTRY(__put_user_1)
1: TUSER(strb)	r2, [r0]
	mov	r0, #0
	mov	pc, lr
ENDPROC(__put_user_1)

ENTRY(__put_user_2)
	mov	ip, r2, lsr #8
#ifdef CONFIG_THUMB2_KERNEL
#ifndef __ARMEB__
2: TUSER(strb)	r2, [r0]
3: TUSER(strb)	ip, [r0, #1]
#else
2: TUSER(strb)	ip, [r0]
3: TUSER(strb)	r2, [r0, #1]
#endif
#else	/* !CONFIG_THUMB2_KERNEL */
#ifndef __ARMEB__
2: TUSER(strb)	r2, [r0], #1
3: TUSER(strb)	ip, [r0]
#else
2: TUSER(strb)	ip, [r0], #1
3: TUSER(strb)	r2, [r0]
#endif
#endif	/* CONFIG_THUMB2_KERNEL */
	mov	r0, #0
	mov	pc, lr
ENDPROC(__put_user_2)

ENTRY(__put_user_4)
4: TUSER(str)	r2, [r0]
	mov	r0, #0
	mov	pc, lr
ENDPROC(__put_user_4)

ENTRY(__put_user_8)
#ifdef CONFIG_THUMB2_KERNEL
5: TUSER(str)	r2, [r0]
6: TUSER(str)	r3, [r0, #4]
#else
5: TUSER(str)	r2, [r0], #4
6: TUSER(str)	r3, [r0]
#endif
	mov	r0, #0
	mov	pc, lr
ENDPROC(__put_user_8)
```

 `getuser.S`에서는 ENTRY 매크로를 통해 각 크기 name label을 보여줄 수 있게 정의를 해두었다.

 또한 위 작업은 메모리 데이터에 직접 엑세스 하는 과정이다. 이러한 과정이 필요한 이유는 ARM architecture 의 경우 레지스터 - 메모리 간 데이터에 직접 엑세스가 불가능하여, `LDR`/ `STR` 명령을 통해서만 가능하다. 전반적인 과정 설명이 아닌 ARM만의 간략한 설명을 하겠다.

```assembly
LDR r3, [r0, #1]
STR r3, [r2], #2
```

 **Line. 01**의 경우 r0 레지스터로에 1 byte만큼 더한 주소에서 **int** 값을 읽어 r3 레지스터에 저장한다.

 **Line. 02**의 경우 r2 레지스터의 주소에 r1 레지스터 값을 저장한 뒤 r2 레지스터를 4만큼 증가시킨다.

 추가로 알아야 할 것은 위에서 int 형을 강조하였듯  `LDRB`의 경우 byte, `LDRH`는 short에 사용된다. 

## 2-3. Vulnerability analysis

 실질적으로 취약한 code는 하기와 같다.

```c
// File: /arch/arm/include/asm/uaccess.h

extern int __get_user_1(void *);
extern int __get_user_2(void *);
extern int __get_user_4(void *);

#define __get_user_x(__r2,__p,__e,__s,__i...)		\
	   __asm__ __volatile__ (			\
		__asmeq("%0", "r0") __asmeq("%1", "r2")	\
		"bl	__get_user_" #__s		\				// asms, ASM 코드
		: "=&r" (__e), "=r" (__r2)		\	// output, 결과 출력 변수
		: "0" (__p)				\							// input, asms에 넘겨줄 입력 변수
		: __i, "cc")										// clobber, 상기에 명시되진 않았지만 asms로 인해 값이 변하는 변수

#define __put_user_x(__r2,__p,__e,__s)		\
		 __asm__ __volatile__ (				\
     __asmeq("%0", "r0") __asmeq("%2", "r2")	\
     "bl	__put_user_" #__s		\			// asms, ASM 코드
     : "=&r" (__e)				\					// output, 결과 출력 변수
     : "0" (__p), "r" (__r2)			\	// input, asms에 넘겨줄 입력 변수
     : "ip", "lr", "cc")						// clobber, 상기에 명시되진 않았지만 asms로 인해 값이 변하는 변수
```

 간단히 정리하자면 위 code audit에서 살펴본 코드 중 그 어디에도 범위 혹은 길이에 대한 제한 혹은 조건이 없다. 이는 ARM architecture의 Domain 기능을 사용하여 메모리 구역을 나누어두지 않거나 지원하지 않는다면 공격자가 원하는 값을 R/W 할 수 있다.

# 4. Proof of concept

# 5. Patch for the vulnerability

 기존 commit을 바탕으로 변경 사항 추적을 해보았다.

```assembly
// File: /arch/arm/include/asm/assembler.h
// ...

\name:
	.asciz "\string"
	.size \name , . - \name
	.endm

	.macro check_uaccess, addr:req, size:req, limit:req, tmp:req, bad:req
#ifndef CONFIG_CPU_USE_DOMAINS
	adds	\tmp, \addr, #\size - 1
	sbcccs	\tmp, \tmp, \limit
	bcs	\bad
#endif
	.endm

#endif /* __ASM_ASSEMBLER_H__ */
```

 우선 `uaccess.h` 내에서 사용 될 매크로를 추가한다. 이는 `limit`과 `addr`, `size`를 통해 한계 주소 값을 넘지 않는지 확인 하는 과정이다. `ADDS`를 통해 플래그도 바꿔주는 것이 중요점이다.

```assembly
// File: arch/arm/include/asm/uaccess.h

extern int __get_user_1(void *);
extern int __get_user_2(void *);
extern int __get_user_4(void *);

#define __GUP_CLOBBER_1	"lr", "cc"
#ifdef CONFIG_CPU_USE_DOMAINS
#define __GUP_CLOBBER_2	"ip", "lr", "cc"
#else
#define __GUP_CLOBBER_2 "lr", "cc"
#endif
#define __GUP_CLOBBER_4	"lr", "cc"

/* #define __get_user_x(__r2,__p,__e,__s,__i...)	*/
#define __get_user_x(__r2,__p,__e,__l,__s)				\

	   __asm__ __volatile__ (					\
		__asmeq("%0", "r0") __asmeq("%1", "r2")			\
		__asmeq("%3", "r1")					\
		"bl	__get_user_" #__s				\
		: "=&r" (__e), "=r" (__r2)				\
		
/*		: "0" (__p)						\
			: __i, "cc")	*/
		: "0" (__p), "r" (__l)					\
		: __GUP_CLOBBER_##__s)
		
#define get_user(x,p)							\
	({								\
		unsigned long __limit = current_thread_info()->addr_limit - 1; \
		register const typeof(*(p)) __user *__p asm("r0") = (p);\
		register unsigned long __r2 asm("r2");			\
		register unsigned long __l asm("r1") = __limit;		\
		register int __e asm("r0");				\
		switch (sizeof(*(__p))) {				\
		case 1:							\
		
//			__get_user_x(__r2, __p, __e, 1, "lr");		\
//	       		break;						\

			__get_user_x(__r2, __p, __e, __l, 1);		\
			break;						\
		case 2:							\
		
/* 			__get_user_x(__r2, __p, __e, 2, "r3", "lr");	\ */
			__get_user_x(__r2, __p, __e, __l, 2);		\
			
			break;						\
		case 4:							\

/*	  	__get_user_x(__r2, __p, __e, 4, "lr");		\ */
			__get_user_x(__r2, __p, __e, __l, 4);		\
			
			break;						\
		default: __e = __get_user_bad(); break;			\
		}							\
		x = (typeof(*(p))) __r2;				\
		__e;							\
	})
	
	/* #define __put_user_x(__r2,__p,__e,__s)					\ */
	#define __put_user_x(__r2,__p,__e,__l,__s)				\
	
	   __asm__ __volatile__ (					\
		__asmeq("%0", "r0") __asmeq("%2", "r2")			\
		__asmeq("%3", "r1")					\
		"bl	__put_user_" #__s				\
		: "=&r" (__e)						\
		
/*		: "0" (__p), "r" (__r2)					\	*/
		: "0" (__p), "r" (__r2), "r" (__l)			\
		
		: "ip", "lr", "cc")

#define put_user(x,p)							\
	({								\
		unsigned long __limit = current_thread_info()->addr_limit - 1; \
		register const typeof(*(p)) __r2 asm("r2") = (x);	\
		register const typeof(*(p)) __user *__p asm("r0") = (p);\
		register unsigned long __l asm("r1") = __limit;		\
		register int __e asm("r0");				\
		switch (sizeof(*(__p))) {				\
		case 1:							\
		
/*			__put_user_x(__r2, __p, __e, 1);		\	*/
			__put_user_x(__r2, __p, __e, __l, 1);		\
			
			break;						\
		case 2:							\
		
/*			__put_user_x(__r2, __p, __e, 2);		\	*/
			__put_user_x(__r2, __p, __e, __l, 2);		\
			
			break;						\
		case 4:							\
		
/*			__put_user_x(__r2, __p, __e, 4);		\	*/
			__put_user_x(__r2, __p, __e, __l, 4);		\
			
			break;						\
		case 8:							\
		
/*			__put_user_x(__r2, __p, __e, 8);		\	*/
			__put_user_x(__r2, __p, __e, __l, 8);		\
			
			break;						\
		default: __e = __put_user_bad(); break;			\
		}	
```

```assembly
// File: /arch/arm/lib/getuser.S

/*
 * __get_user_X
 *
 * Inputs:	r0 contains the address
 
 *		r1 contains the address limit, which must be preserved
 
 * Outputs:	r0 is the error code
 
// *		r2, r3 contains the zero-extended value
 *		r2 contains the zero-extended value
 
 *		lr corrupted
 *
 */
 
 #include <asm/assembler.h>

ENTRY(__get_user_1)
/*	check_uaccess r0, 1, r1, r2, __get_user_bad	*/
1: TUSER(ldrb)	r2, [r0]
	mov	r0, #0
	mov	pc, lr
ENDPROC(__get_user_1)

ENTRY(__get_user_2)
/*	#ifdef CONFIG_THUMB2_KERNEL
		2: TUSER(ldrb)	r2, [r0]
		3: TUSER(ldrb)	r3, [r0, #1]	*/
	check_uaccess r0, 2, r1, r2, __get_user_bad
#ifdef CONFIG_CPU_USE_DOMAINS
rb	.req	ip
2:	ldrbt	r2, [r0], #1
3:	ldrbt	rb, [r0], #0

#else
/*	2: TUSER(ldrb)	r2, [r0], #1
		3: TUSER(ldrb)	r3, [r0]	*/
rb	.req	r0
2:	ldrb	r2, [r0]
3:	ldrb	rb, [r0, #1]

#endif
#ifndef __ARMEB__

/*	orr	r2, r2, r3, lsl #8	*/
	orr	r2, r2, rb, lsl #8
	
#else

/*	orr	r2, r3, r2, lsl #8	*/
	orr	r2, rb, r2, lsl #8
	
#endif
	mov	r0, #0
	mov	pc, lr
ENDPROC(__get_user_2)

ENTRY(__get_user_4)

	check_uaccess r0, 4, r1, r2, __get_user_bad

4: TUSER(ldr)	r2, [r0]
	mov	r0, #0
	mov	pc, lr
```

```assembly
// File: /arch/arm/lib/putuser.S

/*
 * __put_user_X
 *
 * Inputs:	r0 contains the address
 *		r1 contains the address limit, which must be preserved
 *		r2, r3 contains the value
 * Outputs:	r0 is the error code
 *		lr corrupted
 *
 * No other registers must be altered.  (see <asm/uaccess.h>
 * for specific ASM register usage).
 */
 
 #include <asm/assembler.h>

ENTRY(__put_user_1)

	check_uaccess r0, 1, r1, ip, __put_user_bad
	
1: TUSER(strb)	r2, [r0]
	mov	r0, #0
	mov	pc, lr
ENDPROC(__put_user_1)

ENTRY(__put_user_2)

	check_uaccess r0, 2, r1, ip, __put_user_bad

	mov	ip, r2, lsr #8
#ifdef CONFIG_THUMB2_KERNEL
#ifndef __ARMEB__

...

ENTRY(__put_user_4)

	check_uaccess r0, 4, r1, ip, __put_user_bad
	
4: TUSER(str)	r2, [r0]
	mov	r0, #0
	mov	pc, lr
ENDPROC(__put_user_4)

ENTRY(__put_user_8)

	check_uaccess r0, 8, r1, ip, __put_user_bad
	
#ifdef CONFIG_THUMB2_KERNEL
5: TUSER(str)	r2, [r0]
6: TUSER(str)	r3, [r0, #4]
```



# 6. Conclusion

# 7. Reference

- https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2013-6282

- https://cve.report/CVE-2013-6282

- https://nvd.nist.gov/vuln/detail/CVE-2013-6282

- https://ubuntu.com/security/CVE-2013-6282

- https://access.redhat.com/security/cve/cve-2013-6282

- https://security-tracker.debian.org/tracker/CVE-2013-6282

- https://vuldb.com/ko/?id.11226

- https://www.mend.io/vulnerability-database/CVE-2013-6282

- https://mirrors.edge.kernel.org/pub/linux/kernel/v3.x/ChangeLog-3.5.5

- https://github.com/torvalds/linux/commit/8404663f81d212918ff85f493649a7991209fa04

- https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=8404663f81d212918ff85f493649a7991209fa04

- https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/arch/arm/include/asm/uaccess.h?id=8404663f81d212918ff85f493649a7991209fa04

  

- https://web.archive.org/web/20140327052415/https://www.codeaurora.org/projects/security-advisories/missing-access-checks-putusergetuser-kernel-api-cve-2013-6282

- https://lore.kernel.org

- https://developer.arm.com/documentation/ddi0406/c/System-Level-Architecture/System-Control-Registers-in-a-VMSA-implementation/VMSA-System-control-registers-descriptions--in-register-order/DACR--Domain-Access-Control-Register--VMSA

- https://developer.arm.com/documentation/ddi0388/i/system-control/register-summary/virtual-memory-control-registers

- https://wiki.kldp.org/KoreanDoc/html/EmbeddedKernel-KLDP

- https://blog.csdn.net/ce123_zhouwei/article/details/8209702

  

- https://elixir.bootlin.com

- https://codebrowser.dev/
